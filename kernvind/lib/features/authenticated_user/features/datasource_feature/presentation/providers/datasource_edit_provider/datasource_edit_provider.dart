import 'package:flutter/foundation.dart';
import 'package:kernvind/core/error/freezed_classes/failure_error.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/domain/entities/datasource_add_feed_entity.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/domain/entities/datasource_update_entity.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/presentation/providers/datasource_details_provider/datasource_details_provider.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/presentation/providers/datasource_edit_provider/datasource_edit_state.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/presentation/providers/datasource_feature_datasource_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
part 'datasource_edit_provider.g.dart';

@riverpod
class DatasourceEdit extends _$DatasourceEdit {
  @override
  DatasourceEditState build() {
    return const DatasourceEditStateInitial();
  }

  void setLoadingState() {
    state = const DatasourceEditStateLoading();
  }

  void setInitialState() {
    state = const DatasourceEditStateInitial();
  }

  Future<void> updateNameAndDesc(
      {required DatasourceUpdateEntity datasource}) async {
    state = const DatasourceEditStateLoading();
    final datasourceRepositoryImpl = ref.read(dataSourceRepositoryImplProvider);
    final datasourceDetailsOrFailure = await datasourceRepositoryImpl
        .updateDatasourceNameAndDesc(datasource: datasource);
    datasourceDetailsOrFailure
        .fold((error) => state = DatasourceNameAndDescEditStateFailure(error),
            (datasourceDetails) {
      state = const DatasourceEditStateSuccess();
      ref
          .read(datasourceDetailsProvider(
                  datasourceId: datasourceDetails.datasource.datasourceId)
              .notifier)
          .setDatasourceDetailsState(datasourceDetails: datasourceDetails);
    });
  }

  Future<void> addDatasourceDatafeed(
      {required DatasourceAddFeedEntity datasourceFeed}) async {
    state = const DatasourceEditStateLoading();
    final datasourceRepositoryImpl = ref.read(dataSourceRepositoryImplProvider);
    final datasourceDetailsOrFailure = await datasourceRepositoryImpl
        .addDatasourceFeed(datasourceFeed: datasourceFeed);
    datasourceDetailsOrFailure.fold(
        (error) => state = DatafeedAddtateFailure(error), (datasourceDetails) {
      state = const DatasourceEditStateSuccess();
      ref
          .read(datasourceDetailsProvider(
                  datasourceId: datasourceDetails.datasource.datasourceId)
              .notifier)
          .setDatasourceDetailsState(datasourceDetails: datasourceDetails);
    });
  }

  Future<void> deleteDatasource({required int datasourceId}) async {
    final datasourceRepositoryImpl = ref.read(dataSourceRepositoryImplProvider);
    final datasourceDeleteOrFailure = await datasourceRepositoryImpl
        .deleteDatasource(datasourceId: datasourceId);
    datasourceDeleteOrFailure.fold(
        (error) => state = DatasourceDeleteStateFailure(error),
        (success) => state = const DatasourceDeleteStateSuccess());
  }

  Future<void> deleteDatasourceFeed({required int datafeedId}) async {
    final datasourceRepositoryImpl = ref.read(dataSourceRepositoryImplProvider);
    final datasourceFeedDeleteOrFailure = await datasourceRepositoryImpl
        .deleteDatasourceFeed(datafeedId: datafeedId);
    datasourceFeedDeleteOrFailure
        .fold((error) => state = DatafeedDeleteStateFailure(error),
            (datasourceDetails) {
      state = const DatasourceFeedDeleteStateSuccess();
      ref
          .read(datasourceDetailsProvider(
                  datasourceId: datasourceDetails.datasource.datasourceId)
              .notifier)
          .setDatasourceDetailsState(datasourceDetails: datasourceDetails);
    });
  }

  Future<void> validateYoutubeVideo({required String url}) async {
    if (!kIsWeb) {
      YoutubeExplode yt = YoutubeExplode();
      try {
        Video video = await yt.videos.get(url);
        String title = video.title;
        Duration? duration = video.duration;
        VideoId id = video.id;
        ClosedCaptionManifest trackManifest =
            await yt.videos.closedCaptions.getManifest(id);
        List<ClosedCaptionTrackInfo> trackInfo =
            trackManifest.getByLanguage('en');
        if (trackInfo.isEmpty) {
          trackInfo = trackManifest.getByLanguage('en-GB');
        }
        if (trackInfo.isEmpty) {
          trackInfo = trackManifest.getByLanguage('en', autoGenerated: true);
        }
        if (trackInfo.isEmpty) {
          state = DatafeedAddtateFailure(FailureError(
              error:
                  'The provided video does not have english closed captions'));
          return;
        }
        if (duration == null) {
          state = DatafeedAddtateFailure(
              FailureError(error: 'The provided video can not be processed'));
          return;
        }
        if (duration.inMinutes > 360) {
          state = DatafeedAddtateFailure(FailureError(
              error:
                  'Only 6 hours or shorter videos are supported. The provided video is more than 6 hours'));
          return;
        }
        state = DatasourceEditStateYoutubeValidationSuccess(
            videoId: id.value, videoTitle: title);
      } catch (e) {
        state = DatafeedAddtateFailure(FailureError(error: e.toString()));
      }
    } else {
      url = '$url&&&&';
      RegExp regExp = RegExp('.*?v(=|/)(.+?)&.+');
      final matches = regExp.allMatches(url);
      if (matches.isEmpty) {
        state = DatafeedAddtateFailure(
            FailureError(error: 'Not a valid youtube video link'));
        return;
      }
      final match = matches.first;
      if (match.groupCount != 2) {
        state = DatafeedAddtateFailure(
            FailureError(error: 'Not a valid youtube video link'));
        return;
      }
      state = DatasourceEditStateYoutubeValidationSuccess(
          videoId: match[2]!, videoTitle: 'FROM WEB');
    }
  }
}
