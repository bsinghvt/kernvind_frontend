import 'package:flutter/foundation.dart';
import 'package:kernvind/core/error/freezed_classes/failure_error.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/domain/entities/datasource_create_entity.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/presentation/providers/datasource_create_provider/datasource_create_provider_state.dart';
import 'package:kernvind/features/authenticated_user/features/datasource_feature/presentation/providers/datasource_feature_datasource_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
part 'datasource_create_provider.g.dart';

@riverpod
class DatasourceCreate extends _$DatasourceCreate {
  @override
  DatasourceCreateProviderState build() {
    return DatasourceCreateProviderStateInitial();
  }

  void setLoadingState() {
    state = DatasourceCreateProviderStateLoading();
  }

  void setInitialState() {
    state = DatasourceCreateProviderStateInitial();
  }

  Future<void> createDatasource(
      {required DatasourceCreateEntity datasource}) async {
    state = DatasourceCreateProviderStateLoading();

    final datasourceRepo = ref.read(dataSourceRepositoryImplProvider);
    final failureOrCreate =
        await datasourceRepo.createDatasource(datasource: datasource);
    failureOrCreate.fold(
        (error) => state = DatasourceCreateProviderStateFailure(error),
        (datasource) =>
            state = DatasourceCreateProviderStateSuccess(datasource));
  }

  Future<void> validateYoutubeVideo({required String url}) async {
    if (!kIsWeb) {
      YoutubeExplode yt = YoutubeExplode();
      try {
        Video video = await yt.videos.get(url);
        String title = video.title;
        Duration? duration = video.duration;
        VideoId id = video.id;
        ClosedCaptionManifest trackManifest =
            await yt.videos.closedCaptions.getManifest(id);
        List<ClosedCaptionTrackInfo> trackInfo =
            trackManifest.getByLanguage('en');
        if (trackInfo.isEmpty) {
          trackInfo = trackManifest.getByLanguage('en-GB');
        }
        if (trackInfo.isEmpty) {
          trackInfo = trackManifest.getByLanguage('en', autoGenerated: true);
        }
        if (trackInfo.isEmpty) {
          state = DatasourceCreateProviderStateFailure(FailureError(
              error:
                  'The provided video does not have english closed captions'));
          return;
        }
        if (duration == null) {
          state = DatasourceCreateProviderStateFailure(
              FailureError(error: 'The provided video can not be processed'));
          return;
        }
        if (duration.inMinutes > 360) {
          state = DatasourceCreateProviderStateFailure(FailureError(
              error:
                  'Only 6 hours or shorter videos are supported. The provided video is more than 6 hours'));
          return;
        }
        state = DatasourceCreateProviderStateYoutubeValidationSuccess(
            videoId: id.value, videoTitle: title);
      } catch (e) {
        state = DatasourceCreateProviderStateFailure(
            FailureError(error: e.toString()));
      }
    } else {
      url = '$url&&&&';
      RegExp regExp = RegExp('.*?v(=|/)(.+?)&.+');
      final matches = regExp.allMatches(url);
      if (matches.isEmpty) {
        state = DatasourceCreateProviderStateFailure(
            FailureError(error: 'Not a valid youtube video link'));
        return;
      }
      final match = matches.first;
      if (match.groupCount != 2) {
        state = DatasourceCreateProviderStateFailure(
            FailureError(error: 'Not a valid youtube video link'));
        return;
      }
      state = DatasourceCreateProviderStateYoutubeValidationSuccess(
          videoId: match[2]!, videoTitle: 'FROM WEB');
    }
  }
}
